{
    "FilePath": "res/shaders/RayMarching.inr",
    "Name": "RayMarching.shader",
    "ResourceType": 4,
    "ShaderSource": "#shader vertex\r\n#version 330 core\r\n\r\nlayout(location = 0) in vec3 position;\r\nlayout(location = 1) in vec3 normal;\r\nlayout(location = 2) in vec2 texCoords;\r\nlayout(location = 3) in vec3 tangent;\r\nlayout(location = 4) in vec3 binormal;\r\n\r\nout DATA\r\n{\r\n\tvec2 texCoord;\r\n} vs_out;\r\n\r\nuniform mat4 u_ViewProjectionMatrix;\r\nuniform mat4 u_ModelMatrix;\r\n\r\nvoid main()\r\n{\r\n\tvs_out.texCoord = texCoords;\r\n\tgl_Position = u_ViewProjectionMatrix * u_ModelMatrix * vec4(position, 1.0);\r\n}\r\n\r\n#shader fragment\r\n#version 330 core\r\n\r\nconst int MAX_MARCHING_STEPS = 255;\r\nconst float MIN_DIST = 0.0;\r\nconst float MAX_DIST = 100.0;\r\nconst float EPSILON = 0.0001;\r\n\r\nlayout(location = 0) out vec4 fragColor;\r\n\r\nin DATA\r\n{\r\n\tvec2 texCoord;\r\n} fs_in;\r\n\r\nuniform vec2 resolution;\r\nuniform float iTime;\r\n\r\n/**\r\n * Signed distance function for a sphere centered at the origin with radius 1.0;\r\n */\r\nfloat sphereSDF(vec3 samplePoint) {\r\n    return length(samplePoint) - 1.0;\r\n}\r\n\r\n/**\r\n * Signed distance function describing the scene.\r\n * \r\n * Absolute value of the return value indicates the distance to the surface.\r\n * Sign indicates whether the point is inside or outside the surface,\r\n * negative indicating inside.\r\n */\r\nfloat sceneSDF(vec3 samplePoint) {\r\n    return sphereSDF(samplePoint);\r\n}\r\n\r\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\r\n    float depth = start;\r\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\r\n        float dist = sceneSDF(eye + depth * marchingDirection);\r\n        if (dist < EPSILON) {\r\n\t\t\treturn depth;\r\n        }\r\n        depth += dist;\r\n        if (depth >= end) {\r\n            return end;\r\n        }\r\n    }\r\n    return end;\r\n}\r\n\r\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\r\n    vec2 xy = fragCoord - size / 2.0;\r\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\r\n    return normalize(vec3(xy, -z));\r\n}\r\n\r\nvec3 estimateNormal(vec3 p) {\r\n    return normalize(vec3(\r\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\r\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\r\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\r\n    ));\r\n}\r\n\r\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\r\n                          vec3 lightPos, vec3 lightIntensity) {\r\n    vec3 N = estimateNormal(p);\r\n    vec3 L = normalize(lightPos - p);\r\n    vec3 V = normalize(eye - p);\r\n    vec3 R = normalize(reflect(-L, N));\r\n    \r\n    float dotLN = dot(L, N);\r\n    float dotRV = dot(R, V);\r\n    \r\n    if (dotLN < 0.0) {\r\n        // Light not visible from this point on the surface\r\n        return vec3(0.0, 0.0, 0.0);\r\n    } \r\n    \r\n    if (dotRV < 0.0) {\r\n        // Light reflection in opposite direction as viewer, apply only diffuse\r\n        // component\r\n        return lightIntensity * (k_d * dotLN);\r\n    }\r\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\r\n}\r\n\r\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\r\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\r\n    vec3 color = ambientLight * k_a;\r\n    \r\n    vec3 light1Pos = vec3(4.0 * sin(iTime),\r\n                          2.0,\r\n                          4.0 * cos(iTime));\r\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\r\n    \r\n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\r\n                                  light1Pos,\r\n                                  light1Intensity);\r\n    \r\n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\r\n                          2.0 * cos(0.37 * iTime),\r\n                          2.0);\r\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\r\n    \r\n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\r\n                                  light2Pos,\r\n                                  light2Intensity);    \r\n    return color;\r\n}\r\n\r\nuniform vec3 K_a = vec3(0.2, 0.4, 0.2);\r\nuniform vec3 K_d = vec3(0.1, 0.2, 0.8);\r\nuniform vec3 K_s = vec3(1.0, 1.0, 1.0);\r\n\r\nvoid main()\r\n{\r\n    /* RAY MARCHING\r\n\r\n    vec3 dir = rayDirection(45.0, resolution.xy, fs_in.texCoord);\r\n    vec3 eye = vec3(0.0, 0.0, 5.0);\r\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\r\n    \r\n    if (dist > MAX_DIST - EPSILON) {\r\n        // Didn't hit anything\r\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\r\n\t\treturn;\r\n    }\r\n    \r\n    // The closest point on the surface to the eyepoint along the view ray\r\n    vec3 p = eye + dist * dir;\r\n    \r\n   \r\n    \r\n    \r\n    float shininess = 10.0;\r\n    \r\n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\r\n    \r\n    fragColor = vec4(color, 1.0); */\r\n\r\n    fragColor = vec4(sin(fs_in.texCoord * 300), 0.0, 1.0);\r\n}",
    "UUID": "{67BA94CC-600A-11EA-8925-18568071B000}"
}
