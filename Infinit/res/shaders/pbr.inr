{
    "FilePath": "res/shaders/pbr.inr",
    "GLSource": "#shader vertex\r\n#version 430 core\r\n\r\nlayout(location = 0) in vec3 a_Position;\r\nlayout(location = 1) in vec3 a_Normal;\r\nlayout(location = 2) in vec2 a_TexCoord;\r\nlayout(location = 3) in vec3 a_Tangent;\r\nlayout(location = 4) in vec3 a_Binormal;\r\n\r\nuniform mat4 u_ViewProjectionMatrix;\r\nuniform mat4 u_ModelMatrix;\r\n\r\nout VertexOutput\r\n{\r\n\tvec3 WorldPosition;\r\n    vec3 Normal;\r\n\tvec2 TexCoord;\r\n\tmat3 WorldNormals;\r\n} vs_Output;\r\n\r\nvoid main()\r\n{\r\n\tvs_Output.WorldPosition = vec3(mat4(u_ModelMatrix) * vec4(a_Position, 1.0));\r\n    vs_Output.Normal = a_Normal;\r\n\tvs_Output.TexCoord = vec2(a_TexCoord.x, 1.0 - a_TexCoord.y);\r\n\tvs_Output.WorldNormals = mat3(u_ModelMatrix) * mat3(a_Tangent, a_Binormal, a_Normal);\r\n\r\n\tgl_Position = u_ViewProjectionMatrix * u_ModelMatrix * vec4(a_Position, 1.0);\r\n}\r\n\r\n#shader fragment\r\n#version 430 core\r\n\r\nconst float PI = 3.141592;\r\nconst float Epsilon = 0.00001;\r\nconst float TO_RADIANS = (PI / 180.0);\r\n\r\nconst int LightCount = 1;\r\n\r\n// Constant normal incidence Fresnel factor for all dielectrics.\r\nconst vec3 Fdielectric = vec3(0.04);\r\n\r\nstruct Light {\r\n\tvec3 Direction;\r\n\tvec3 Radiance;\r\n};\r\n\r\nin VertexOutput\r\n{\r\n\tvec3 WorldPosition;\r\n    vec3 Normal;\r\n\tvec2 TexCoord;\r\n\tmat3 WorldNormals;\r\n} vs_Input;\r\n\r\nlayout(location=0) out vec4 color;\r\n\r\nuniform Light lights;\r\nuniform vec3 u_CameraPosition;\r\n\r\n// PBR texture inputs\r\nuniform sampler2D u_AlbedoTexture;\r\nuniform sampler2D u_NormalTexture;\r\nuniform sampler2D u_MetalnessTexture;\r\nuniform sampler2D u_RoughnessTexture;\r\n\r\n// Environment maps\r\nuniform samplerCube u_EnvRadianceTex;\r\nuniform samplerCube u_EnvIrradianceTex;\r\n\r\n// BRDF LUT\r\nuniform sampler2D u_BRDFLUTTexture;\r\n\r\nuniform vec3 u_AlbedoColor;\r\nuniform float u_Metalness;\r\nuniform float u_Roughness;\r\n\r\nuniform float u_EnvMapRotation;\r\n\r\n// Toggles\r\nuniform float u_RadiancePrefilter;\r\nuniform bool u_AlbedoTexToggle;\r\nuniform bool u_NormalTexToggle;\r\nuniform bool u_MetalnessTexToggle;\r\nuniform bool u_RoughnessTexToggle;\r\n\r\nstruct PBRParameters\r\n{\r\n\tvec3 Albedo;\r\n\tfloat Roughness;\r\n\tfloat Metalness;\r\n\r\n\tvec3 Normal;\r\n\tvec3 View;\r\n\tfloat NdotV;\r\n};\r\n\r\nPBRParameters m_Params;\r\n\r\n// GGX/Towbridge-Reitz normal distribution function.\r\n// Uses Disney's reparametrization of alpha = roughness^2\r\nfloat ndfGGX(float cosLh, float roughness)\r\n{\r\n\tfloat alpha = roughness * roughness;\r\n\tfloat alphaSq = alpha * alpha;\r\n\r\n\tfloat denom = (cosLh * cosLh) * (alphaSq - 1.0) + 1.0;\r\n\treturn alphaSq / (PI * denom * denom);\r\n}\r\n\r\n// Single term for separable Schlick-GGX below.\r\nfloat gaSchlickG1(float cosTheta, float k)\r\n{\r\n\treturn cosTheta / (cosTheta * (1.0 - k) + k);\r\n}\r\n\r\n// Schlick-GGX approximation of geometric attenuation function using Smith's method.\r\nfloat gaSchlickGGX(float cosLi, float NdotV, float roughness)\r\n{\r\n\tfloat r = roughness + 1.0;\r\n\tfloat k = (r * r) / 8.0; // Epic suggests using this roughness remapping for analytic lights.\r\n\treturn gaSchlickG1(cosLi, k) * gaSchlickG1(NdotV, k);\r\n}\r\n\r\nfloat GeometrySchlickGGX(float NdotV, float roughness)\r\n{\r\n    float r = (roughness + 1.0);\r\n    float k = (r*r) / 8.0;\r\n\r\n    float nom   = NdotV;\r\n    float denom = NdotV * (1.0 - k) + k;\r\n\r\n    return nom / denom;\r\n}\r\n\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\r\n{\r\n    float NdotV = max(dot(N, V), 0.0);\r\n    float NdotL = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\r\n\r\n    return ggx1 * ggx2;\r\n}\r\n\r\n// Shlick's approximation of the Fresnel factor.\r\nvec3 fresnelSchlick(vec3 F0, float cosTheta)\r\n{\r\n\treturn F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\n\r\nvec3 fresnelSchlickRoughness(vec3 F0, float cosTheta, float roughness)\r\n{\r\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\r\n} \r\n\r\n// ---------------------------------------------------------------------------------------------------\r\n// The following code (from Unreal Engine 4's paper) shows how to filter the environment map\r\n// for different roughnesses. This is mean to be computed offline and stored in cube map mips,\r\n// so turning this on online will cause poor performance\r\nfloat RadicalInverse_VdC(uint bits) \r\n{\r\n    bits = (bits << 16u) | (bits >> 16u);\r\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\r\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\r\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\r\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\r\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\r\n}\r\n\r\nvec2 Hammersley(uint i, uint N)\r\n{\r\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\r\n}\r\n\r\nvec3 ImportanceSampleGGX(vec2 Xi, float Roughness, vec3 N)\r\n{\r\n\tfloat a = Roughness * Roughness;\r\n\tfloat Phi = 2 * PI * Xi.x;\r\n\tfloat CosTheta = sqrt( (1 - Xi.y) / ( 1 + (a*a - 1) * Xi.y ) );\r\n\tfloat SinTheta = sqrt( 1 - CosTheta * CosTheta );\r\n\tvec3 H;\r\n\tH.x = SinTheta * cos( Phi );\r\n\tH.y = SinTheta * sin( Phi );\r\n\tH.z = CosTheta;\r\n\tvec3 UpVector = abs(N.z) < 0.999 ? vec3(0,0,1) : vec3(1,0,0);\r\n\tvec3 TangentX = normalize( cross( UpVector, N ) );\r\n\tvec3 TangentY = cross( N, TangentX );\r\n\t// Tangent to world space\r\n\treturn TangentX * H.x + TangentY * H.y + N * H.z;\r\n}\r\n\r\nfloat TotalWeight = 0.0;\r\n\r\nvec3 PrefilterEnvMap(float Roughness, vec3 R)\r\n{\r\n\tvec3 N = R;\r\n\tvec3 V = R;\r\n\tvec3 PrefilteredColor = vec3(0.0);\r\n\tint NumSamples = 1024;\r\n\tfor(int i = 0; i < NumSamples; i++)\r\n\t{\r\n\t\tvec2 Xi = Hammersley(i, NumSamples);\r\n\t\tvec3 H = ImportanceSampleGGX(Xi, Roughness, N);\r\n\t\tvec3 L = 2 * dot(V, H) * H - V;\r\n\t\tfloat NoL = clamp(dot(N, L), 0.0, 1.0);\r\n\t\tif (NoL > 0)\r\n\t\t{\r\n\t\t\tPrefilteredColor += texture(u_EnvRadianceTex, L).rgb * NoL;\r\n\t\t\tTotalWeight += NoL;\r\n\t\t}\r\n\t}\r\n\treturn PrefilteredColor / TotalWeight;\r\n}\r\n\r\n// ---------------------------------------------------------------------------------------------------\r\n\r\nvec3 RotateVectorAboutY(float angle, vec3 vec)\r\n{\r\n    angle = radians(angle);\r\n    mat3x3 rotationMatrix ={vec3(cos(angle),0.0,sin(angle)),\r\n                            vec3(0.0,1.0,0.0),\r\n                            vec3(-sin(angle),0.0,cos(angle))};\r\n    return rotationMatrix * vec;\r\n}\r\n\r\nvec3 Lighting(vec3 F0)\r\n{\r\n\tvec3 result = vec3(0.0);\r\n\tfor(int i = 0; i < LightCount; i++)\r\n\t{\r\n\t\tvec3 Li = -(lights.Direction * TO_RADIANS);\r\n\t\tvec3 Lradiance = lights.Radiance;\r\n\t\tvec3 Lh = normalize(Li + m_Params.View);\r\n\r\n\t\t// Calculate angles between surface normal and various light vectors.\r\n\t\tfloat cosLi = max(0.0, dot(m_Params.Normal, Li));\r\n\t\tfloat cosLh = max(0.0, dot(m_Params.Normal, Lh));\r\n\r\n\t\tvec3 F = fresnelSchlick(F0, max(0.0, dot(Lh, m_Params.View)));\r\n\t\tfloat D = ndfGGX(cosLh, m_Params.Roughness);\r\n\t\tfloat G = gaSchlickGGX(cosLi, m_Params.NdotV, m_Params.Roughness);\r\n\r\n\t\tvec3 kd = (1.0 - F) * (1.0 - m_Params.Metalness);\r\n\t\tvec3 diffuseBRDF = kd * m_Params.Albedo;\r\n\r\n\t\t// Cook-Torrance\r\n\t\tvec3 specularBRDF = (F * D * G) / max(Epsilon, 4.0 * cosLi * m_Params.NdotV);\r\n\r\n\t\tresult += (diffuseBRDF + specularBRDF) * Lradiance * cosLi;\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nvec3 IBL(vec3 F0, vec3 Lr)\r\n{\r\n\tvec3 irradiance = texture(u_EnvIrradianceTex, m_Params.Normal).rgb;\r\n\tvec3 F = fresnelSchlickRoughness(F0, m_Params.NdotV, m_Params.Roughness);\r\n\tvec3 kd = (1.0 - F) * (1.0 - m_Params.Metalness);\r\n\tvec3 diffuseIBL = m_Params.Albedo * irradiance;\r\n\r\n\tint u_EnvRadianceTexLevels = textureQueryLevels(u_EnvRadianceTex);\r\n\tfloat NoV = clamp(m_Params.NdotV, 0.0, 1.0);\r\n\tvec3 R = 2.0 * dot(m_Params.View, m_Params.Normal) * m_Params.Normal - m_Params.View;\r\n\tvec3 specularIrradiance = vec3(0.0);\r\n\r\n\tif (u_RadiancePrefilter > 0.5)\r\n\t\tspecularIrradiance = PrefilterEnvMap(m_Params.Roughness * m_Params.Roughness, R) * u_RadiancePrefilter;\r\n\telse\r\n\t\tspecularIrradiance = textureLod(u_EnvRadianceTex, RotateVectorAboutY(u_EnvMapRotation, Lr), sqrt(m_Params.Roughness) * u_EnvRadianceTexLevels).rgb * (1.0 - u_RadiancePrefilter);\r\n\r\n\t// Sample BRDF Lut, 1.0 - roughness for y-coord because texture was generated (in Sparky) for gloss model\r\n\tvec2 specularBRDF = texture(u_BRDFLUTTexture, vec2(m_Params.NdotV, 1.0 - m_Params.Roughness)).rg;\r\n\tvec3 specularIBL = specularIrradiance * (F * specularBRDF.x + specularBRDF.y);\r\n\r\n\treturn kd * diffuseIBL + specularIBL;\r\n}\r\n\r\nvoid main()\r\n{\r\n\t// Standard PBR inputs\r\n\tm_Params.Albedo = u_AlbedoTexToggle ? texture(u_AlbedoTexture, vs_Input.TexCoord).rgb : u_AlbedoColor; \r\n\tm_Params.Metalness = u_MetalnessTexToggle ? texture(u_MetalnessTexture, vs_Input.TexCoord).r : u_Metalness;\r\n\tm_Params.Roughness = u_RoughnessTexToggle ?  texture(u_RoughnessTexture, vs_Input.TexCoord).r : u_Roughness;\r\n    m_Params.Roughness = max(m_Params.Roughness, 0.05); // Minimum roughness of 0.05 to keep specular highlight\r\n\r\n\t// Normals (either from vertex or map)\r\n\tm_Params.Normal = normalize(vs_Input.Normal);\r\n\tif (u_NormalTexToggle)\r\n\t{\r\n\t\tm_Params.Normal = normalize(2.0 * texture(u_NormalTexture, vs_Input.TexCoord).rgb - 1.0);\r\n\t\tm_Params.Normal = normalize(vs_Input.WorldNormals * m_Params.Normal);\r\n\t}\r\n\r\n\tm_Params.View = normalize(u_CameraPosition - vs_Input.WorldPosition);\r\n\tm_Params.NdotV = max(dot(m_Params.Normal, m_Params.View), 0.0);\r\n\t\t\r\n\t// Specular reflection vector\r\n\tvec3 Lr = 2.0 * m_Params.NdotV * m_Params.Normal - m_Params.View;\r\n\r\n\t// Fresnel reflectance, metals use albedo\r\n\tvec3 F0 = mix(Fdielectric, m_Params.Albedo, m_Params.Metalness);\r\n\r\n\tvec3 lightContribution = Lighting(F0);\r\n\tvec3 iblContribution = IBL(F0, Lr);\r\n\r\n\t//color = vec4(texture(u_AlbedoTexture, vs_Input.TexCoord));\r\n\t//color = vec4(m_Params.Metalness , m_Params.Roughness, 0.0, 1.0);\r\n\tcolor = vec4(lightContribution + iblContribution, 1.0);\r\n\t//color = vec4(m_Params.Albedo, 1.0);\r\n}",
    "Name": "pbr.shader",
    "Type": 4
}
